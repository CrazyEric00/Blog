---
title: 杭电ACM1072题：带条件的逃离迷宫题（bfs与dfs两种方法AC）
url: 45.html
id: 45
categories:
  - ACM
  - 杭电oj
date: 2018-04-27 23:28:00
tags:
---

这次还是深搜与广搜的话题，上次找了一道经典的深搜广搜迷宫题（杭电oj1072题），一看这个题目就有浓厚的搜索气息 ![](http://39.107.233.145/wp-content/uploads/2018/04/1-2.png) ![](http://39.107.233.145/wp-content/uploads/2018/04/2-1.png) 今天为了省去大家移驾到杭电看题，所以今天贴心地给出了谷歌翻译版 ![](http://39.107.233.145/wp-content/uploads/2018/04/3-1.png) ![](http://39.107.233.145/wp-content/uploads/2018/04/4-1.png) 所以上面的题目叽叽喳喳说了这么多，实际上就可以总结为，如何在六步与爆炸还原装置点的条件下完成迷宫的最短路径。这题就是很明显的广搜与深搜题，简直如假包换。那么，既然是深搜与广搜，那么我们该选择那种搜索方案才能更好地解题呢。这里，我得出一个与杭电讨论区大神们差不多的结论。即广搜便于理解但代码量较多，同时也使用了数据结构----队列和自己定义的结构体node；反观深搜，虽然在代码量上有较大改进，也没有使用别的数据结构，但是其复杂的递归使人望而生却。好了，话不多说，请各位进入正题自己体会。 首先我们进入广度优先搜索的主题，由于这一题可以作为很多没接触过搜索算法的同学的入门题，所以我特意找了一些便于理解的例子。 首先介绍图结构，由于这里不是讲解数据结构的，我只给出一个示意图先 ![](http://39.107.233.145/wp-content/uploads/2018/04/5.png)![](http://39.107.233.145/wp-content/uploads/2018/04/6.png)   咱们的题给出的二维数组就可以看做一张图，深度搜索与广度搜索的本质区别就是遍历的先后顺序而已。深度搜索是往一个方向上死磕，走到不能走位置（一头倔驴）；而广度搜索就是先走遍他的上下左右邻里亲戚，先把周围的邻居都认识了再去认识邻居的邻居（一个好邻居）。所以这哥俩的特性就赋予了他们在解题时不同的功效。 那么，我们要做到广度搜索，就得先把他的邻居一个一个存起来，然后一个一个拿出来继续搜索邻居的邻居，那么，我们就要借助先进先出的数据结构了，没错，就是队列。 ![](http://39.107.233.145/wp-content/uploads/2018/04/1-3-1024x468.png) 在上述图片中，这个人的邻居1,2,3,4会按顺序进入队列排队。然后程序走完这个起点，就会从队列中拿出第一个数据，把第一个数据当做起点。 然后再把1号的邻居再放入队列，由于队列是先进先出的结构，所以1号的邻居5,6,7,8就得等2,3,4走完才能被访问到。 ![](http://39.107.233.145/wp-content/uploads/2018/04/2-2-1024x468.png) 所以这题的广搜解法就是使用一个队列，那么队列里该存什么呢，一不做二不休，我们何不自己定义一个结构体存储每一步的数据呢。 \[cpp\] typedef struct node{ int x; //当前节点的x坐标 int y; //当前节点的y坐标 int boom;//当前节点离炸弹爆炸的步数 int step;//当前节点已走步数 }; \[/cpp\] 这样只要对队列进行操作，我们就可以遍历整个二维数组了。注意还要对炸弹爆炸做出操作，当boom==0时就直接结束这一条路的遍历，但是 不影响别的路。根据广度搜索的特性，最快走到终点的路肯定是步数最少的，只要有一条路通了，我们立刻可以结束对二维数组的遍历，这条 最快到达的路一定是步数最少的（具体细节请同学们细细品味）。 这题还有一个小细节（广度搜索的细节就是这么多），就是关于到达炸弹重置装置之后回头走老路的情况，在这里注意注意注意绝对不能使用 记忆化数组或者剪枝，我们的办法就是允许数组在遍历时走老路（但是不能再次走到炸弹重置装置上，必须在使用完炸弹重置装置后将装置 变成墙壁0），这样虽然在复杂度上高了一些，但是确实是解决允许走回头路的好办法（虽然看似简单粗暴）。下面贴出AC的广度优先搜索代 码： \[cpp\] #include <iostream> #include <queue> #define INF 10000000 using namespace std; typedef struct node{ int x; //当前节点的x坐标 int y; //当前节点的y坐标 int boom;//当前节点离炸弹爆炸的步数 int step;//当前节点已走步数 }; int n,m; int sx,sy,ex,ey; int a\[10\]\[10\]; int dx\[4\]={0,0,-1,1},dy\[4\]={1,-1,0,0}; int d\[10\]\[10\]; void bfs(){ queue<node> que; d\[sx\]\[sy\]=0; node start; start.x=sx; start.y=sy; start.boom=6; start.step=0; que.push(start); while(que.size()){ node p=que.front(); que.pop(); if(p.boom==0) break; for(int i=0;i<4;i++){ node q; q.x=p.x+dx\[i\]; q.y=p.y+dy\[i\]; q.boom=p.boom-1; q.step=p.step+1; if(q.x>=0&&q.x<n&&q.y>=0&&q.y<m&&a\[q.x\]\[q.y\]!=0&&d\[q.x\]\[q.y\]!=0&&q.boom>0){ if(a\[q.x\]\[q.y\]==4){ q.boom=6; a\[q.x\]\[q.y\]=0; d\[q.x\]\[q.y\]=0; } else if(q.x==ex&&q.y==ey){ cout << q.step << endl; return; } que.push(q); } } } cout << "-1" << endl; } int main() { int cas; while(cin>>cas){ while(cas--){ cin >> n >> m; for(int i=0;i<n;i++){ for(int j=0;j<m;j++){ cin>>a\[i\]\[j\]; d\[i\]\[j\]=INF; if(a\[i\]\[j\]==2){ sx=i; sy=j; } if(a\[i\]\[j\]==3){ ex=i; ey=j; } } } bfs(); } } return 0; } \[/cpp\] 接下来就是深度搜索啦，深度搜索顾名思义就是一条路走到底，这种特性就意味着终点的值会被一遍一遍地更新知道最小为止，因为深度搜索有很多的递归要完成，所以我们使用了两个二维数组进行记忆化（这也是深度搜索中必不可少的），通过这两个二维数组存储递归中的信息来使算法进行的更加正确，效率更高。给出AC代码： \[cpp\] #include <iostream> #define INF 10000000 using namespace std; int n,m; int sx,sy,ex,ey; int a\[10\]\[10\]; int dx\[4\]={0,0,-1,1},dy\[4\]={1,-1,0,0}; int d\[10\]\[10\];//作为辅助的步数信息 int b\[10\]\[10\];//作为辅助的炸弹信息 int ans; void dfs(int x,int y,int boom,int step){ //与广度搜索一样都需进行便捷的判断 if(x<0||x>=n||y<0||y>=m) return; //当炸弹爆炸这条路径就return，表示失败 if(boom==0) return; //不能走墙壁 if(a\[x\]\[y\]==0) return; //到终点了，只要步数比上几条路径用的少就更新最短路径信息 if(a\[x\]\[y\]==3){ if(step<ans) ans=step; return; } //走到炸弹重置装置就恢复时间 if(a\[x\]\[y\]==4) boom=6; //只有当步数小且炸弹爆炸剩余时间比上一次路径多的时候才继续遍历 if(step>=d\[x\]\[y\]&&boom<=b\[x\]\[y\]) return; d\[x\]\[y\]=step; b\[x\]\[y\]=boom; //四个方向进行深度搜索 for(int i=0;i<4;i++){ int nx=x+dx\[i\]; int ny=y+dy\[i\]; dfs(nx,ny,boom-1,step+1); } } int main() { int cas; while(cin>>cas){ while(cas--){ cin>>n>>m; for(int i=0;i<n;i++){ for(int j=0;j<m;j++){ cin >> a\[i\]\[j\]; if(a\[i\]\[j\]==2){ sx=i; sy=j; } d\[i\]\[j\]=INF; b\[i\]\[j\]=0; } } ans=INF; dfs(sx,sy,6,0); if(ans==INF) cout << "-1" <<endl; else cout << ans << endl; } } return 0; } \[/cpp\] 不知道大家注意到一个很关键的条件没有，就是下面这行代码

#### if(step>=d\[x\]\[y\]&&boom<=b\[x\]\[y\]) return;

步数小可以继续操作还算是很好理解的，红色部分很难理解但却是如何解决绕路回头问题的关键，我们的b数组是对整个地图炸弹爆炸时间的记录，那么为什么要写这个条件呢。 关键点就在于走得多远的问题，只有这条路能比上一条路走得远，我才可以有去遍历这条路的必要，如果这条路走过了炸弹重置装置，却还没有上一条路走得远，并且步数还比上一条遍历的路多，那我们就根本没有走这条路的必要！！。通俗点来讲，这条路已经不是潜力股了。那么我们就直接放弃（就是这么残忍）。 那么至此深搜与广搜的方法都已经介绍过了，我们下一篇见！
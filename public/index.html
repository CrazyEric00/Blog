<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>In The End</title>
  <meta name="author" content="Eric">
  
  <meta name="description" content="爱好ACM与算法">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="In The End"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70812759-1', 'auto');
  ga('send', 'pageview');
</script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cb5448498d7169c668b07c2b255d62c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">In The End</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>Eric的个人博客<span class="blink-fast">∎</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <i class="fa fa-heart blink-slow"></i>
      Keep and carry on.
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/07/18/个人博客2-0上线了/" >个人博客2.0上线了</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-07-18  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		
	
	</div>
  <a type="button" href="/2018/07/18/个人博客2-0上线了/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/07/18/e9-93-be-e5-bc-8f-e5-93-88-e5-b8-8c-e8-a1-a8-ef-bc-88-e5-85-ab-e6-95-b0-e7-a0-81-e9-97-ae-e9-a2-98-e6-89-a9-e5-b1-95-ef-bc-89/" >链式哈希表（八数码问题扩展）</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-07-18  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>哈哈，疯狂更新！又是八数码问题，这次是写另一种判重方法，也是一种比较常用的方法/数据结构 上一篇文章中的八数码问题中可以不使用康托展开，虽然康托展开是完美哈希（一一对应）的，但是就是因为其完美哈希（一一对应）的这个特质，所以在节点多入牛毛时，你的内存空间还是会爆炸，因为就算康托展开地再完美，也还是无法减少情况，毕竟是一一对应，根本减少不了好吧。所以，在康托都救不了你了，Hash还是可以拯救你一下子的。 接下来就是数据结构的知识了，我们推出主角——哈希表（散列表） 哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 记录的存储位置=f(关键字) 这里的对应关系f称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。 数组的特点是：寻址容易，插入和删除困难； 而链表的特点是：寻址困难，插入和删除容易。 我们综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图： <img src="http://39.107.233.145/wp-content/uploads/2018/07/哈希表.jpeg" alt=""> 左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。 然后当我们查找时，我们只需要查找一个范围，也就是使用O（1）时间查到这个链表头，之后再进行普通的比较是否一样 小tips：我们在选取hash函数时必须要慎重，举个例子，如果你的hash函数把所有的状态全部映射成了一个值，那么你的哈希表也就只有一条链表了，那这就非常糟糕了。  关键字——散列函数（哈希函数）——散列地址 优点：一对一的查找效率很高； 缺点：一个关键字可能对应多个散列地址；需要查找一个范围时，效果不好；有时候会退化成几条长长的链表。 散列冲突：不同的关键字经过散列函数的计算得到了相同的散列地址。 好的散列函数=计算简单+分布均匀（计算得到的散列地址分布均匀） 哈希表是种数据结构，它可以提供快速的插入操作和查找操作。  优缺点 优点：不论哈希表中有多少数据，查找、插入、删除（有时包括删除）只需要接近常量的时间即0(1）的时间级。实际上，这只需要几条机器指令。 哈希表运算得非常快，在计算机程序中，如果需要在一秒种内查找上千条记录通常使用哈希表（例如拼写检查器)哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。 如果不需要有序遍历数据，并且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。 缺点：它是基于数组的，数组创建后难于扩展，某些哈希表被基本填满时，性能下降得非常严重，所以程序员必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。</p>
<h2 id="代码实现（以前一篇博客的八数码问题举例）："><a href="#代码实现（以前一篇博客的八数码问题举例）：" class="headerlink" title="代码实现（以前一篇博客的八数码问题举例）："></a>代码实现（以前一篇博客的八数码问题举例）：</h2><p>[cpp] #include <iostream> #include <cstring> #include <vector> using namespace std; const int N=9; const int maxn=1000000;//9个数字组成的状态的数量 const int hashsize=100;//链式哈希表的head（链头）的最大数量 int head[hashsize],next[100000]; int st[maxn][N];//保存八数码状态的数组 //哈希函数，将一位数组变成一个数字，乘10的倍数相加，so easy！ int hash(const int<em> s) { int val = 0; for (int i = 0; i &lt; N; i++) val = val </em> 10 + s[i]; return val % hashsize; } //判重的函数，也是添加链表的函数 bool judge(int s){ int val=hash(st[s]);//先取出哈希值 int u=head[val];//找到该哈希值代表的头 while(u){//看看链表节点存不存在，不存在跳过，直接添加 if(memcmp(st[u],st[s], sizeof(st[s]))==0)//如果存在则进行普通判重比较，这里直接用内存比，效率高 return false;//发现重合返回false u=next[u];//不然则继续向后比较 } //没发现重合的就会结束循环出来，我们进行下面的添加链表操作 next[s]=head[val];//直接头节点接入新节点后面 head[val]=s;//然后将新节点作为新的头节点 return true;//返回true } [/cpp] OK,哈希表的问题我们就说到这里，明天更新一个有趣的倒水问题。 PS：暑假期间博客争取日更，不知道这是不是一个FLAG</vector></cstring></iostream></p>

	
	</div>
  <a type="button" href="/2018/07/18/e9-93-be-e5-bc-8f-e5-93-88-e5-b8-8c-e8-a1-a8-ef-bc-88-e5-85-ab-e6-95-b0-e7-a0-81-e9-97-ae-e9-a2-98-e6-89-a9-e5-b1-95-ef-bc-89/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/07/17/e5-85-ab-e6-95-b0-e7-a0-81-e9-97-ae-e9-a2-98bfs-e5-ba-b7-e6-89-98-e5-b1-95-e5-bc-80/" >八数码问题(BFS+康托展开)</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-07-17  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>真香警告！ 这是ACM江湖传说中不做后悔的题！ 你还有一秒钟的时间撤离战场！ 好，你已经来不及了！ 接下来让我们看看今天的主角——八数码问题。 <img src="http://39.107.233.145/wp-content/uploads/2018/07/game.jpg" alt="">不知道大家小时候有没有玩过这个类似于拼图的游戏，我们的目标是要把左边的拼图通过一个空格作为媒介变成右边的拼图的样子（肯定有很多人玩过，但是是通过图片而不是数字，我记得好像windows桌面小工具里就有这个游戏），所以，今天就用计算机来解决这个游戏，输出它的最佳解决方案。 先看看题目吧，POJ1077题，传送门：<a href="http://poj.org/problem?id=1077" target="_blank" rel="noopener">http://poj.org/problem?id=1077</a> 题意就是输入一个九宫格（字符串），空格用’x’表示，然后我们需要找出把空格怼到最下方且数字还要按顺序排布的移动方案（如图为目标） <img src="http://39.107.233.145/wp-content/uploads/2018/07/mubiao.jpg" alt=""> 好的废话不多说我们开始分析问题。 首先我们选用BFS来解决这个问题，以空格为起始点，让空格上下左右移动并记录下来，有一个问题是我们需要先解决的，我们得先把x变成数字，那么究竟是变成0还是变成9呢，我这里推荐变成9（我一开始变成0麻烦了一些，不过也不是不行）。为什么要变成9呢？原因就在于康托展开（不熟悉康托展开的同学请易步至我的前一篇博客，这里不再做过多的赘述），在康托展开中，123456789的字典序为0，而123456780的字典序则需要手动调试一次康托展开进行计算（虽然我这里算出来了是46233），所以就比较麻烦，在争分夺秒的环境下推荐直接用123456789，这样心里有底肯定错不了。如图所示 <img src="http://39.107.233.145/wp-content/uploads/2018/07/9.jpeg" alt=""> 好，然后就是重点了，为什么我们要费尽心机讲了这么多的康托展开，原因就在于，当我们BFS这个八数码的时候，我们怎么去判断这个形态我们已经上一次移动过了（简而言之就是不能走回头路，别移着移着又移回来了），我们开一个9维的vis数组去保存？别逗了！我们直接保存1-9的排列组合不就成了，9！=362880完全ok啊，这就得轮到康托展开大显身手的时候了，所以，在这个问题中我们只需写出康托展开的编码函数与解码函数，然后将BFS的每一步的父节点记下来，最后回溯即可。 给出一张BFS搜索图加深理解： <img src="http://39.107.233.145/wp-content/uploads/2018/07/搜索图.jpeg" alt=""> 接下来就是AC代码： [cpp] #include <cstring> #include <iostream> #include <algorithm> #include <vector> #include <stack> #include <queue> #include <string> using namespace std; const int N = 362880; int vis[N]; int par[N]; int dir[N]; //这里手动记下了1-9的阶乘，提高效率 const int fact[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}; const int dx[]={-1,1,0,0}; const int dy[]={0,0,-1,1}; struct Node { char s[9]; int loc; }; //康托展开编码函数 int encode(const char *a) { int i,j,t,sum; sum=0; for( i=0; i&lt;9 ;++i) { t=0; for(j=i+1;j&lt;9;++j) if( a[i]&gt;a[j] ) ++t; sum+=t*fact[9-i-1]; } return sum+1; } //康托展开解码函数 void decode(int k,Node&amp; node) { int i, j, t, vst[10] = {0}; –k; for (i = 0; i &lt; 9; i++) { t = k / fact[9 - i - 1]; for (j = 1; j &lt;= 9; j++) if (!vst[j]) { if (t == 0) break; –t; } node.s[i] = j; vst[j] = 1; k %= fact[9 - i - 1]; } for(int i=0;i&lt;9;i++){ if((int)node.s[i]==9){ node.loc=i; break; } } } //搜索 void bfs(const Node&amp; begin) { memset(vis, 0, sizeof(vis)); int code = encode(begin.s); vis[code] = 1; par[code] = -1;//保存了每一步的父节点,便于输出答案 queue<int> que;//BFS标准配置，队列一个，放入康托展开后的编码 que.push(code); Node n1, n2; while(!que.empty()) { int u = que.front(); que.pop(); decode(u, n1); int k = n1.loc;//loc记下空格所在的位置，方便日后换位 int x = k/3; int y = k%3; for(int i=0; i&lt;4; ++i) { int nx = x + dx[i]; int ny = y + dy[i]; if(nx&gt;=0 &amp;&amp; nx<3 &&="" ny="">=0 &amp;&amp; ny&lt;3) { n2 = n1; n2.loc = nx <em> 3 + ny; swap(n2.s[k], n2.s[n2.loc]);//进行换位你 int v = encode(n2.s);//重新利用康托展开编码 if(!vis[v]) { dir[v] = i;//保存方向 vis[v] = 1;//表示已经访问 par[v] = u;//记录父节点 if(v==1) return; que.push(v); } } } } } void output() { int n, u; char path[1000]; n = 1; path[0] = dir[1]; u = par[1]; while(par[u]!=-1) { path[n] = dir[u]; ++n; u = par[u]; } for(int i=n-1; i&gt;=0; –i) { if(path[i]==0) cout &lt;&lt; “u”; else if(path[i]==1) cout &lt;&lt; “d”; else if(path[i]==2) cout &lt;&lt; “l”; else cout &lt;&lt; “r”; } } int main() { ios::sync_with_stdio(false); cin.tie(0); Node start; char c; for(int i=0; i&lt;9; ++i) { cin &gt;&gt; c; if(c==’x’) { start.s[i] = 9;//当发现了x，将其变成9 start.loc = i; } else start.s[i] = c - ‘0’; } bfs(start); if(vis[1]==1) output(); else cout &lt;&lt; “unsolvable”; cout &lt;&lt; endl; return 0; } [/cpp] 接下来放上一个预告，别以为八数码问题这就解决了，在以后，我还会更新关于八数码的问题，那时候就得用上A</em>算法（启发式搜索）解决这个问题了。</3></int></string></queue></stack></vector></algorithm></iostream></cstring></p>

	
	</div>
  <a type="button" href="/2018/07/17/e5-85-ab-e6-95-b0-e7-a0-81-e9-97-ae-e9-a2-98bfs-e5-ba-b7-e6-89-98-e5-b1-95-e5-bc-80/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/07/16/e5-ba-b7-e6-89-98-e5-b1-95-e5-bc-80-ef-bc-88-e5-85-a8-e6-8e-92-e5-88-97-e4-b8-8e-e8-87-aa-e7-84-b6-e6-95-b0-e7-9a-84-e5-8f-8c-e5-b0-84-ef-bc-89/" >康托展开（全排列与自然数的双射）</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-07-16  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>今天来写一个比较简单的算法，叫做康托展开。 算法中使用编码与解码的场景是非常多的（例如我接下来要写的八数码问题），比如，一个九宫格中数字的排布，或者一个字符串字符的排布，如果我们使用map或者set来判定是否重复，是非常耗时的，有可能就会疯狂TLE，那么我们此时就可以选择康托先生发明的算法来用O(1)的时间解决重合的问题。 <img src="http://39.107.233.145/wp-content/uploads/2018/07/康托.jpeg" alt="">首先介绍一下，这个人就叫康托，是一位德国的大数学家，主要是研究集合论的，还涉及到了实变函数等高端数学知识（不过这不是我们今天要讨论的），让我们看看19世纪的康托是怎么解决这个问题的。</p>
<h2 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h2><p>首先介绍一下康托展开的定义：康托展开是一个全排列到一个自然数的双射，常用于构建hash表时的空间压缩。设有n个数（1，2，3，4,…,n），可以有组成不同(n!种)的排列组合，康托展开表示的就是是当前排列组合在n个不同元素的全排列中的名次。 什么叫做双射呢，就是指双向映射，正好就对应于计算机中的编码与解码。其中的编码映射对应于这样一个公式： <strong><code>X=a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[i]*(i-1)!+...+a[1]*0!</code></strong> 我们来解析一下a[n]代表的意思 <img src="http://39.107.233.145/wp-content/uploads/2018/07/公式-1024x304.png" alt=""> 其中, a[i]为整数，并且0 &lt;= a[i] &lt;= i, 0 &lt;= i &lt; n, 表示当前未出现的的元素中排第几个，这就是康托展开。 例如有3个数（1，2，3），则其排列组合及其相应的康托展开值如下： <img src="http://39.107.233.145/wp-content/uploads/2018/07/表-1024x339.png" alt=""> 比如其中的 231：</p>
<ul>
<li>想要计算排在它前面的排列组合数目（123，132，213），则可以转化为计算算比首位小及小于2的所有排列「1 <em> 2！」，首位相等及为2第二位小于3的所有排列「1\</em>1！」，前两位相等及为23第三位小于1的所有排列（0*0！）的和即可，康托展开为：1*2！+1*1+0*0=3。</li>
<li>所以小于231的组合有3个，所以231的名次是4。</li>
</ul>
<p>再举个例子说明。 在（1，2，3，4，5）5个数的排列组合中，计算 34152的康托展开值。</p>
<ul>
<li>首位是3，则小于3的数有两个，为1和2，a[5]=2，则首位小于3的所有排列组合为 a[0]*(5-1)!</li>
<li>第二位是4，则小于4的数有两个，为1和2，注意这里3并不能算，因为3已经在第一位，所以其实计算的是在第二位之后小于4的个数。因此a[4]=2</li>
<li>第三位是1，则在其之后小于1的数有0个，所以a[3]=0</li>
<li>第四位是5，则在其之后小于5的数有1个，为2，所以a[2]=1</li>
<li>最后一位就不用计算啦，因为在它之后已经没有数了，所以a[1]固定为0</li>
<li>根据公式： <code>X = 2 * 4! + 2 * 3! + 0 * 2! + 1 * 1! + 0 * 0! = 2 * 24 + 2 * 6 + 1 = 61</code></li>
<li>所以比 34152 小的组合有61个，即34152是排第62</li>
</ul>
<p>具体代码实现如下： [cpp] int vis[362880];//因为9!=362880所以开辟362880，不放心可以多开几个 int fact[9];//保存0-8的阶乘值，方便计算 void init(){//首先打印出0-8阶乘的值直接保存在fact数组 memset(vis,0,sizeof(vis)); fact[0]=1; for(int i=1;i&lt;9;i++){ fact[i]=fact[i-1]*i;//使用前一个数组值快速求阶乘 } } int encode(const char *a)//编码函数 { int i,j,t,sum; sum=0; for( i=0; i&lt;9 ;++i) { t=0; for(j=i+1;j&lt;9;++j) if( a[i]&gt;a[j] ) ++t; sum+=t*fact[9-i-1]; } return sum+1; } [/cpp]</p>
<h2 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h2><p>一开始已经提过了，康托展开是一个全排列到一个自然数的<strong>双射</strong>，因此是可逆的。即对于上述例子，在（1，2，3，4，5）给出61可以算出起排列组合为 34152。由上述的计算过程可以容易的逆推回来，具体过程如下：</p>
<ul>
<li>用 61 / 4! = 2余13，说明a[5]=2,说明比首位小的数有2个，所以首位为3。</li>
<li>用 13 / 3! = 2余1，说明a[4]=2，说明在第二位之后小于第二位的数有2个，所以第二位为4。</li>
<li>用 1 / 2! = 0余1，说明a[3]=0，说明在第三位之后没有小于第三位的数，所以第三位为1。</li>
<li>用 1 / 1! = 1余0，说明a[2]=1，说明在第二位之后小于第四位的数有1个，所以第四位为5。</li>
<li>最后一位自然就是剩下的数2啦。</li>
<li>通过以上分析，所求排列组合为 34152。</li>
</ul>
<p>这里放上一段简洁的逆康托展开的代码(经过测试无误)： [cpp] void decode(int k,node) { int i, j, t, vst[10] = {0}; –k; for (i = 0; i &lt; 9; i++) { t = k / fact[9 - i - 1]; for (j = 1; j &lt;= 9; j++) if (!vst[j]) { if (t == 0) break; –t; } node[i] = j; vst[j] = 1; k %= fact[9 - i - 1]; } } [/cpp] PS：下午更新八数码问题，这个康托展开只是因为八数码问题中用到的专门挑出来的前传</p>

	
	</div>
  <a type="button" href="/2018/07/16/e5-ba-b7-e6-89-98-e5-b1-95-e5-bc-80-ef-bc-88-e5-85-a8-e6-8e-92-e5-88-97-e4-b8-8e-e8-87-aa-e7-84-b6-e6-95-b0-e7-9a-84-e5-8f-8c-e5-b0-84-ef-bc-89/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/07/15/leetcode-e5-91-a8-e8-b5-9b-e7-ac-ac93-e5-9c-ba-e8-a7-a3-e9-a2-98-e6-8a-a5-e5-91-8a/" >Leetcode周赛第93场解题报告</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-07-15  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>今天上午打了场leetcode周竞赛。终于进了两百名，灰常开心。 <img src="http://39.107.233.145/wp-content/uploads/2018/07/AK-1024x479.png" alt=""> <img src="http://39.107.233.145/wp-content/uploads/2018/07/排名-1024x323.png" alt="">以下是解题报告。 先附上传送门：<a href="https://leetcode-cn.com/contest/weekly-contest-93" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-93</a> 1.二进制间距 首先第一题叫做二进制间距，就是判断一个数字变成二进制后两个1之间的距离，这题纯考细节。先找到一个1，然后用变量t记忆这个1的位置，然后找到下一个1的位置然后相减即可。 [cpp] class Solution { public: int binaryGap(int N) { int move=0,t=0,ans=0,times=0; while(N&gt;0){ if(N&amp;1){ times++; if(times&gt;1) ans=max(ans,move-t); t=move; } N=N&gt;&gt;1; move++; } if(times&lt;=1) ans=0; return ans; } }; [/cpp] 2.重排序得到2的幂 第二题我没有想到灵巧的解题方式，所以直接使用全排列，先将数字分解，然后使用全排列（注意开头是0的情况必须剔除掉），最后使用位运 算，使得这个数字的二进制表示只有一个1，如果出现了两个及以上，立即剪枝。 [cpp] class Solution { public: bool reorderedPowerOf2(int N) { int s[9],i=0; while(N){ s[i++]=N%10; N/=10; } sort(s,s+i); long long t; int flag; do{ if(s[0]==0) continue; int mul=1; t=0; for(int j=i-1;j&gt;=0;j–){ t+=s[j]*mul; mul*=10; } int times=0; flag=1; while(t){ if(t&amp;1) times++; if(times&gt;1){ flag=0; break; } t=t&gt;&gt;1; } if(flag) break; }while(next_permutation(s,s+i)); if(flag) return true; else return false; } }; [/cpp] 3.优势洗牌 这个问题非常类似于田忌赛马（这个比喻我觉得非常恰当），所以显而易见的我们必须对A数组与B数组进行排序，但是问题在于B数组的原来的 位置我们需要想办法保存下来，因为我们需要输出A数组，当然得与B数组的原来位置一一映射。我一开始使用了map保存了B数组的位置，但是数据量比较大，没想到居然爆内存了。转念过来一想其实直接用pair&lt;int,int&gt;就够了，所以改完之后内存就不爆了。 然后就是upper_bound二分查找，将结果写入ans对应于B数组的原来位置，如果upper_bound没成功，就把A数组最小值放入，类似于田忌赛马中拿下等马去糊弄对方上等马一样。 [cpp] class Solution { public: vector<int> advantageCount(vector<int>&amp; A, vector<int>&amp; B) { vector&lt;pair&lt;int,int&gt;&gt; mp; vector<int> ans; for(int i=0;i&lt;B.size();i++){ mp.push_back(make_pair(B[i],i)); ans.push_back(-1); } sort(mp.begin(),mp.end()); sort(A.begin(),A.end()); for(int i=0;i&lt;B.size();i++){ vector<int>::iterator it=upper_bound(A.begin(),A.end(),mp[i].first); if(it!=A.end()){ ans[mp[i].second]=*it; *it=-1; }else{ int j; for(j=0;j&lt;A.size()&amp;&amp;A[j]==-1;j++); ans[mp[i].second]=A[j]; A[j]=-1; } } return ans; } }; [/cpp] 4.最低加油次数 这道题的关键在于思想的转变，很多人会纠结于加油站的选择问题，其实我们可以换个角度思考。 我们可以让车一直跑，在车消耗掉所有的油之后，我们可以获得已经路过的加油站加油的权利，而不是每到一个加油站都去纠结一下到底加不加油。所以，每当车跑过一个加油站，我们就把这个加油站的油加入优先队列，当车没油时就拿出优先队列最上面的一份（一定是最多的一份）给车加油。相应地，如果车又没油了队列又空了，那么就说明这车跑不到了 [cpp] class Solution { public: int minRefuelStops(int target, int startFuel, vector&lt;vector<int>&gt;&amp; stations) { vector<int> end; end.push_back(target); end.push_back(0); stations.push_back(end); priority_queue<int> que; int ans=0,pos=0; for(int i=0;i&lt;stations.size();i++){ int d=stations[i][0]-pos; while(startFuel-d&lt;0){ if(que.empty()){ return -1; } startFuel+=que.top(); que.pop(); ans++; } startFuel-=d; pos=stations[i][0]; que.push(stations[i][1]); } return ans; } }; [/cpp] OK,这次leetcode周赛的解题报告就结束了，我们下周见！ PS：欢迎喜欢算法的同学一起来刷题讨论！</int></int></int></int></int></int></int></int></p>

	
	</div>
  <a type="button" href="/2018/07/15/leetcode-e5-91-a8-e8-b5-9b-e7-ac-ac93-e5-9c-ba-e8-a7-a3-e9-a2-98-e6-8a-a5-e5-91-8a/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/07/07/e5-9b-9e-e6-ba-af-e6-b3-95-ef-bc-9an-e7-9a-87-e5-90-8e-e9-97-ae-e9-a2-98-ef-bc-88c-e4-b8-8epython3-ef-bc-89/" >回溯法：n皇后问题（C++与Python3）</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-07-07  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<pre><code>hello，我又更新博客了。今天来写一个非常著名的算法——回溯法，而且这次加上了Python的代码实现。  

那么首先来介绍一下今天的主角——回溯法。先借用刘汝佳大佬的话：回溯法是初学者学习暴力法的第一个障碍，学习时间短则数天，长则数月甚至一年以上。听起来有点吓人，对于回溯法，我个人的理解是DFS（深度优先搜索）的一种转化，先对所求目标深入查找，成功则输出，失败则将深入查找过程中修改的值改回来然后换一条路继续搜。

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。
</code></pre><p>我们先从八皇后问题开始看起： <a href="https://baike.baidu.com/item/%E5%85%AB%E7%9A%87%E5%90%8E" target="_blank" rel="noopener">       八皇后</a>问题，是一个古老而著名的问题，是<a href="https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">回溯算法</a>的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 <a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF/24098" target="_blank" rel="noopener">高斯</a>认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以解决此问题。        八皇后问题是一个以国际象棋为背景的问题：如何能够在 8×8 的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n1×n1，而皇后个数也变成n2。而且仅当 n2 = 1 或 n1 ≥ 4 时问题有解。</p>
<pre><code>八皇后问题最早是由国际西洋棋棋手马克斯·贝瑟尔于1848年提出。之后陆续有数学家对其进行研究，其中包括高斯和康托，并且将其推广为更一般的n皇后摆放问题。八皇后问题的第一个解是在1850年由弗朗兹·诺克给出的。诺克也是首先将问题推广到更一般的n皇后摆放问题的人之一。1874年，S.冈德尔提出了一个通过行列式来求解的方法，这个方法后来又被J.W.L.格莱舍加以改进。

艾兹格·迪杰斯特拉在1972年用这个问题为例来说明他所谓结构性编程的能力。没错就是我们最短路径dijkstra算法的创造者（有兴趣的童鞋可以去了解一下这个牛人和他创造的算法）
</code></pre><p><img src="http://39.107.233.145/wp-content/uploads/2018/07/1.jpeg" alt=""> 上图的皇后排布就是一种解法 我们举一反三，如何解决N皇后的问题呢，我们的思路如下：        本算法的思路是按行来规定皇后位置，第一行放置一个皇后，第二行放置一个皇后， 第N行也放置一个皇后… 这样， 可以保证每行都有一个皇后，那么各行的皇后应该放置在那一列呢， 算法通过循环来完成，在循环的过程中， 一旦找到一个合适的列，则该行的皇后位置确定，则继续进行下一行的皇后的位置的确定。由于每一行确定皇后位置的方式相似，所以可以使用递归法。一旦最后 一行的皇后位置确定，则可以得到一组解。找到一组解之后， 之前确定皇后应该放置在哪一列的循环其实才进行了一轮循环的， 算法通过该循环遍历所有的列，以此确定每一行所有可能的列的位置。在从一轮循环进入下一轮循环之前，算法需要清除在上一轮被标记为不可放置皇后的标记，也就是回溯。因为进入下一轮循环之后，同一行的皇后的列的位置会发生了变化，之前被标记为不可放置皇后的列和正反对角线位置都已经失效        下面给出N皇后问题代码实现: C++版本： [cpp] #include <iostream> #include <cstring> using namespace std; int tot; int vis[3][100];//使用二维数组，分别枚举列和两个对角线 void queen(int n,int *A,int cur){ if(cur==n) tot++; else{ for(int i=0;i&lt;n;i++){ if(!vis[0][i]&amp;&amp;!vis[1][i+cur]&amp;&amp;!vis[2][cur-i+n]){ A[cur]=i; vis[0][i]=vis[1][i+cur]=vis[2][cur-i+n]=1; queen(n,A,cur+1); vis[0][i]=vis[1][i+cur]=vis[2][cur-i+n]=0; } } } } int main(){ int n; while(cin&gt;&gt;n) { int *a = new int[n+10]; memset(vis,0, sizeof(vis)); tot=0; queen(n,a,0); cout &lt;&lt; tot &lt;&lt; endl; } return 0; } <pre>[/cpp] python3版本： [python] #这种是常规版的，使用一位数组回溯 def queen(c,cur): if(cur==n): global tot tot+=1 else: for i in range(0,n): ok=1 c[cur]=i; for j in range(0,cur): if(c[cur]==c[j] or cur-c[cur]==j-c[j] or cur+c[cur]==j+c[j]): ok=0 break if(ok): queen(c,cur+1) #这个跟上面的C++版本相同，使用了二维数组存储 def queen2(c,cur): global tot global vis if(cur==n): tot+=1 else: for i in range(n): if(vis[0][i] == 0 and vis[1][cur+i] == 0 and vis[2][cur+n-i] == 0): c[cur]=i vis[0][i]=vis[1][cur+i]=vis[2][cur+n-i]=1 queen2(c,cur+1) vis[0][i]=vis[1][cur+i]=vis[2][cur+n-i]=0 #主函数 if __name__==’__main__‘: while True: try: n=int(input()); tot=0 vis=[[0 for col in range(n+10)] for row in range(3)] print(vis) c=[0]*n queen2(c,0) print(tot) except EOFError: break [/python] OK，今天的回溯法讲完了，当然这只是回溯法的九牛一毛而已，接下来会给大家带来更多回溯法的应用问题</pre></cstring></iostream></p>

	
	</div>
  <a type="button" href="/2018/07/07/e5-9b-9e-e6-ba-af-e6-b3-95-ef-bc-9an-e7-9a-87-e5-90-8e-e9-97-ae-e9-a2-98-ef-bc-88c-e4-b8-8epython3-ef-bc-89/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/07/01/uva10410-e9-a2-98-ef-bc-9a-e6-a0-91-e9-87-8d-e5-bb-ba/" >UVA10410题：树重建</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-07-01  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>今天还是一道关于DFS与BFS的题目，但是对于两种搜索挖的有点深，基本上能学到很多关于DFS与BFS的性质。 废话不多说，我们先来看题<a href="https://vjudge.net/problem/UVA-10410" target="_blank" rel="noopener">https://vjudge.net/problem/UVA-10410</a> <img src="http://39.107.233.145/wp-content/uploads/2018/06/1-174x300.png" alt=""><img src="http://39.107.233.145/wp-content/uploads/2018/06/2-292x300.png" alt=""> 我中文大概概括一下，题目给出n个结点并先后给出BFS序和DFS序，然后你需要用这两个序列还原整棵树（如果有多种输出一种即可）。 额，题目意思非常简洁易懂，但是这题想想明白确实没那么容易（花了好久深入思考了BFS和DFS序，以前真没有仔细研究过，好题好题）。 <img src="http://39.107.233.145/wp-content/uploads/2018/06/3-1024x768.jpg" alt=""> <img src="http://39.107.233.145/wp-content/uploads/2018/06/4-1024x768.jpg" alt=""> <img src="http://39.107.233.145/wp-content/uploads/2018/06/5-1024x768.jpg" alt=""> <img src="http://39.107.233.145/wp-content/uploads/2018/06/6-1024x768.jpg" alt=""> <img src="http://39.107.233.145/wp-content/uploads/2018/06/8-1024x768.jpg" alt=""> <img src="http://39.107.233.145/wp-content/uploads/2018/06/7-1024x768.jpg" alt=""> 所以我们用邻接表和栈可以过这题。下面贴上代码： [cpp] #include <iostream> #include <vector> #include <stack> using namespace std; const int maxn=1010; vector<int> G[maxn]; int num[maxn]; int main(){ ios::sync_with_stdio(false); cin.tie(0); int n; while(cin&gt;&gt;n){ int t; for(int i=0;i&lt;n;i++){ cin&gt;&gt;t; num[t]=i; G[i].clear(); } cin&gt;&gt;t; int root=t; stack<int> s; s.push(root); for(int i=1;i&lt;n;i++){ cin&gt;&gt;t; while(true){ int u=s.top(); if(num[u]+1&lt;num[t]||(num[u]+1==num[t]&amp;&amp;u&gt;t)){ G[u].push_back(t); s.push(t); break; } else{ s.pop(); } } } for(int i=1;i&lt;=n;i++){ cout &lt;&lt; i &lt;&lt; ‘:’; for(int j=0;j&lt;G[i].size();j++){ cout &lt;&lt;’ ‘&lt;&lt; G[i][j]; } cout &lt;&lt; endl; } } return 0; } [/cpp] 最后今天晚上法国打阿根廷了，虽然不怎么看好这届阿根廷，但 <img src="http://39.107.233.145/wp-content/uploads/2018/06/8.gif" alt=""></int></int></stack></vector></iostream></p>

	
	</div>
  <a type="button" href="/2018/07/01/uva10410-e9-a2-98-ef-bc-9a-e6-a0-91-e9-87-8d-e5-bb-ba/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/04/28/e6-9d-ad-e7-94-b5acm1072-e9-a2-98-ef-bc-9a-e5-b8-a6-e6-9d-a1-e4-bb-b6-e7-9a-84-e9-80-83-e7-a6-bb-e8-bf-b7-e5-ae-ab-e9-a2-98-ef-bc-88bfs-e4-b8-8edfs-e4-b8-a4-e7-a7-8d-e6-96-b9-e6-b3-95ac-trashed/" >杭电ACM1072题：带条件的逃离迷宫题（bfs与dfs两种方法AC）</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-04-28  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>这次还是深搜与广搜的话题，上次找了一道经典的深搜广搜迷宫题（杭电oj1072题），一看这个题目就有浓厚的搜索气息 <img src="http://39.107.233.145/wp-content/uploads/2018/04/1-2.png" alt=""> <img src="http://39.107.233.145/wp-content/uploads/2018/04/2-1.png" alt=""> 今天为了省去大家移驾到杭电看题，所以今天贴心地给出了谷歌翻译版 <img src="http://39.107.233.145/wp-content/uploads/2018/04/3-1.png" alt=""> <img src="http://39.107.233.145/wp-content/uploads/2018/04/4-1.png" alt=""> 所以上面的题目叽叽喳喳说了这么多，实际上就可以总结为，如何在六步与爆炸还原装置点的条件下完成迷宫的最短路径。这题就是很明显的广搜与深搜题，简直如假包换。那么，既然是深搜与广搜，那么我们该选择那种搜索方案才能更好地解题呢。这里，我得出一个与杭电讨论区大神们差不多的结论。即广搜便于理解但代码量较多，同时也使用了数据结构—-队列和自己定义的结构体node；反观深搜，虽然在代码量上有较大改进，也没有使用别的数据结构，但是其复杂的递归使人望而生却。好了，话不多说，请各位进入正题自己体会。 首先我们进入广度优先搜索的主题，由于这一题可以作为很多没接触过搜索算法的同学的入门题，所以我特意找了一些便于理解的例子。 首先介绍图结构，由于这里不是讲解数据结构的，我只给出一个示意图先 <img src="http://39.107.233.145/wp-content/uploads/2018/04/5.png" alt=""><img src="http://39.107.233.145/wp-content/uploads/2018/04/6.png" alt="">   咱们的题给出的二维数组就可以看做一张图，深度搜索与广度搜索的本质区别就是遍历的先后顺序而已。深度搜索是往一个方向上死磕，走到不能走位置（一头倔驴）；而广度搜索就是先走遍他的上下左右邻里亲戚，先把周围的邻居都认识了再去认识邻居的邻居（一个好邻居）。所以这哥俩的特性就赋予了他们在解题时不同的功效。 那么，我们要做到广度搜索，就得先把他的邻居一个一个存起来，然后一个一个拿出来继续搜索邻居的邻居，那么，我们就要借助先进先出的数据结构了，没错，就是队列。 <img src="http://39.107.233.145/wp-content/uploads/2018/04/1-3-1024x468.png" alt=""> 在上述图片中，这个人的邻居1,2,3,4会按顺序进入队列排队。然后程序走完这个起点，就会从队列中拿出第一个数据，把第一个数据当做起点。 然后再把1号的邻居再放入队列，由于队列是先进先出的结构，所以1号的邻居5,6,7,8就得等2,3,4走完才能被访问到。 <img src="http://39.107.233.145/wp-content/uploads/2018/04/2-2-1024x468.png" alt=""> 所以这题的广搜解法就是使用一个队列，那么队列里该存什么呢，一不做二不休，我们何不自己定义一个结构体存储每一步的数据呢。 [cpp] typedef struct node{ int x; //当前节点的x坐标 int y; //当前节点的y坐标 int boom;//当前节点离炸弹爆炸的步数 int step;//当前节点已走步数 }; [/cpp] 这样只要对队列进行操作，我们就可以遍历整个二维数组了。注意还要对炸弹爆炸做出操作，当boom==0时就直接结束这一条路的遍历，但是 不影响别的路。根据广度搜索的特性，最快走到终点的路肯定是步数最少的，只要有一条路通了，我们立刻可以结束对二维数组的遍历，这条 最快到达的路一定是步数最少的（具体细节请同学们细细品味）。 这题还有一个小细节（广度搜索的细节就是这么多），就是关于到达炸弹重置装置之后回头走老路的情况，在这里注意注意注意绝对不能使用 记忆化数组或者剪枝，我们的办法就是允许数组在遍历时走老路（但是不能再次走到炸弹重置装置上，必须在使用完炸弹重置装置后将装置 变成墙壁0），这样虽然在复杂度上高了一些，但是确实是解决允许走回头路的好办法（虽然看似简单粗暴）。下面贴出AC的广度优先搜索代 码： [cpp] #include <iostream> #include <queue> #define INF 10000000 using namespace std; typedef struct node{ int x; //当前节点的x坐标 int y; //当前节点的y坐标 int boom;//当前节点离炸弹爆炸的步数 int step;//当前节点已走步数 }; int n,m; int sx,sy,ex,ey; int a[10][10]; int dx[4]={0,0,-1,1},dy[4]={1,-1,0,0}; int d[10][10]; void bfs(){ queue<node> que; d[sx][sy]=0; node start; start.x=sx; start.y=sy; start.boom=6; start.step=0; que.push(start); while(que.size()){ node p=que.front(); que.pop(); if(p.boom==0) break; for(int i=0;i&lt;4;i++){ node q; q.x=p.x+dx[i]; q.y=p.y+dy[i]; q.boom=p.boom-1; q.step=p.step+1; if(q.x&gt;=0&amp;&amp;q.x&lt;n&amp;&amp;q.y&gt;=0&amp;&amp;q.y&lt;m&amp;&amp;a[q.x][q.y]!=0&amp;&amp;d[q.x][q.y]!=0&amp;&amp;q.boom&gt;0){ if(a[q.x][q.y]==4){ q.boom=6; a[q.x][q.y]=0; d[q.x][q.y]=0; } else if(q.x==ex&amp;&amp;q.y==ey){ cout &lt;&lt; q.step &lt;&lt; endl; return; } que.push(q); } } } cout &lt;&lt; “-1” &lt;&lt; endl; } int main() { int cas; while(cin&gt;&gt;cas){ while(cas–){ cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;m;j++){ cin&gt;&gt;a[i][j]; d[i][j]=INF; if(a[i][j]==2){ sx=i; sy=j; } if(a[i][j]==3){ ex=i; ey=j; } } } bfs(); } } return 0; } [/cpp] 接下来就是深度搜索啦，深度搜索顾名思义就是一条路走到底，这种特性就意味着终点的值会被一遍一遍地更新知道最小为止，因为深度搜索有很多的递归要完成，所以我们使用了两个二维数组进行记忆化（这也是深度搜索中必不可少的），通过这两个二维数组存储递归中的信息来使算法进行的更加正确，效率更高。给出AC代码： [cpp] #include <iostream> #define INF 10000000 using namespace std; int n,m; int sx,sy,ex,ey; int a[10][10]; int dx[4]={0,0,-1,1},dy[4]={1,-1,0,0}; int d[10][10];//作为辅助的步数信息 int b[10][10];//作为辅助的炸弹信息 int ans; void dfs(int x,int y,int boom,int step){ //与广度搜索一样都需进行便捷的判断 if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m) return; //当炸弹爆炸这条路径就return，表示失败 if(boom==0) return; //不能走墙壁 if(a[x][y]==0) return; //到终点了，只要步数比上几条路径用的少就更新最短路径信息 if(a[x][y]==3){ if(step&lt;ans) ans=step; return; } //走到炸弹重置装置就恢复时间 if(a[x][y]==4) boom=6; //只有当步数小且炸弹爆炸剩余时间比上一次路径多的时候才继续遍历 if(step&gt;=d[x][y]&amp;&amp;boom&lt;=b[x][y]) return; d[x][y]=step; b[x][y]=boom; //四个方向进行深度搜索 for(int i=0;i&lt;4;i++){ int nx=x+dx[i]; int ny=y+dy[i]; dfs(nx,ny,boom-1,step+1); } } int main() { int cas; while(cin&gt;&gt;cas){ while(cas–){ cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;m;j++){ cin &gt;&gt; a[i][j]; if(a[i][j]==2){ sx=i; sy=j; } d[i][j]=INF; b[i][j]=0; } } ans=INF; dfs(sx,sy,6,0); if(ans==INF) cout &lt;&lt; “-1” &lt;&lt;endl; else cout &lt;&lt; ans &lt;&lt; endl; } } return 0; } [/cpp] 不知道大家注意到一个很关键的条件没有，就是下面这行代码</iostream></node></queue></iostream></p>
<h4 id="if-step-gt-d-x-y-amp-amp-boom-lt-b-x-y-return"><a href="#if-step-gt-d-x-y-amp-amp-boom-lt-b-x-y-return" class="headerlink" title="if(step&gt;=d[x][y]&amp;&amp;boom&lt;=b[x][y]) return;"></a>if(step&gt;=d[x][y]&amp;&amp;boom&lt;=b[x][y]) return;</h4><p>步数小可以继续操作还算是很好理解的，红色部分很难理解但却是如何解决绕路回头问题的关键，我们的b数组是对整个地图炸弹爆炸时间的记录，那么为什么要写这个条件呢。 关键点就在于走得多远的问题，只有这条路能比上一条路走得远，我才可以有去遍历这条路的必要，如果这条路走过了炸弹重置装置，却还没有上一条路走得远，并且步数还比上一条遍历的路多，那我们就根本没有走这条路的必要！！。通俗点来讲，这条路已经不是潜力股了。那么我们就直接放弃（就是这么残忍）。 那么至此深搜与广搜的方法都已经介绍过了，我们下一篇见！</p>

	
	</div>
  <a type="button" href="/2018/04/28/e6-9d-ad-e7-94-b5acm1072-e9-a2-98-ef-bc-9a-e5-b8-a6-e6-9d-a1-e4-bb-b6-e7-9a-84-e9-80-83-e7-a6-bb-e8-bf-b7-e5-ae-ab-e9-a2-98-ef-bc-88bfs-e4-b8-8edfs-e4-b8-a4-e7-a7-8d-e6-96-b9-e6-b3-95ac-trashed/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/04/26/e6-9d-ad-e7-94-b5acm1501-e9-a2-98-ef-bc-9adfs-e7-ae-97-e6-b3-95-e4-b8-8e-e8-ae-b0-e5-bf-86-e5-8c-96-e6-90-9c-e7-b4-a2/" >杭电ACM1501题 ：DFS算法与记忆化搜索</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-04-26  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<p>今天准备写一篇关于深搜的题，这是一道经典的深搜题<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1501" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1501</a>   <img src="http://39.107.233.145/wp-content/uploads/2018/04/2.png" alt=""> 题目的大致意思就是有两个单词 tree（A） 和 cat（B） ，保持这两个单词的字母顺序，然后将这两个单词揉合成一个新的单词C，当这个新单词的符合前两个单词的字母顺序时就输出yes，如果新单词打乱了原来这两个单词的字母顺序，输出no。 刚开始做题比较难看出这题是深度搜索，所以一开始的思考方式是三个指针维护三个字符串，用C字符串往后迭代，遇到与A或B相同的字符就将A或B的指针往前移动。那么这个方法很快就会遇到问题。 <img src="http://39.107.233.145/wp-content/uploads/2018/04/3-1024x468.png" alt=""> 上面的例子很幸运地避开了纠结的情况，但是我们不可避免的会遇到i=j=k的情况，这样程序就出现了“分支”。 <img src="http://39.107.233.145/wp-content/uploads/2018/04/4-1024x477.png" alt=""> 那么既然可能会产生如此多的子问题，那么自然而然又变成了深度搜索问题，通过一次一次的函数递归往下深入地搜索，解决多种情况，那么我一开始的计划就是定义一个bool类型返回值的dfs函数。 [cpp] bool dfs(int x,int y,int z){ //x作为a字符串的标记，y作为字符串b的标记，z作为s字符串的标记 if(z==s.length()){ //给出一个正确答案的出口，只要有一条路通往z==s.length() //那么这条路一定是所有分支中最长的路，也是最后return的路 //所以只要有一个正确答案，就会把之前return的false覆盖掉 if(x==a.length()&amp;&amp;y==b.length()) return true; else return false; } //当a和b都找不到这个s的字符时，这个答案必定是no，直接return if(s[z]!=a[x]&amp;&amp;s[z]!=b[y]) return false; //当a和b两者都可以选择时，路径的向上返回的出口设置为二者的或运算 //这一步很容易与下面的代码产生多余的搜索，这也是第一次的超时的原因 if(s[z]==a[x]&amp;&amp;s[z]==b[y]) return dfs(x+1,y,z+1)||dfs(x,y+1,z+1); //这两步就是正常的a，b标记向后移动 if(s[z]==a[x]) return dfs(x+1,y,z+1); if(s[z]==b[y]) return dfs(x,y+1,z+1); } [/cpp] 下面是完整代码 [cpp] #include <iostream> #include <string> using namespace std; string a,b,s; bool dfs(int x,int y,int z){ if(z==s.length()){ if(x==a.length()&amp;&amp;y==b.length()) return true; else return false; } if(s[z]!=a[x]&amp;&amp;s[z]!=b[y]) return false; if(s[z]==a[x]&amp;&amp;s[z]==b[y]) return dfs(x+1,y,z+1)||dfs(x,y+1,z+1); if(s[z]==a[x]) return dfs(x+1,y,z+1); if(s[z]==b[y]) return dfs(x,y+1,z+1); } int main() { int cas; while(cin&gt;&gt;cas){ for(int cot=0;cot&lt;cas;cot++){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;s; if(dfs(0,0,0)) cout &lt;&lt; “yes” &lt;&lt;endl; else cout &lt;&lt; “no” &lt;&lt; endl; } } return 0; } [/cpp] 但是别以为这题就完了，提交到杭电oj，马上就回我一个超时，想来也是，过多的return一定会导致复杂度呈指数型增长。 所以我们需要对深搜进行剪枝，那么就得使用记忆化搜索。 所以定义一个flag的标记数组，然后把返回值设置为void，返回值直接存入flag进行记忆，这样当深度搜索进入到相同的路径时，就可以使用flag数组及时阻止。 以下就是AC的代码 [cpp] #include <iostream> #include <string> #include <cstring> using namespace std; string a,b,s; bool ans; int flag[300][300]; void dfs(int x,int y,int z){ if(z==s.length()&amp;&amp;x==a.length()&amp;&amp;y==b.length()){ ans=true; return; } if(s[z]!=a[x]&amp;&amp;s[z]!=b[y]) return; if(flag[x][y]) return; flag[x][y]=true; if(s[z]==a[x]) dfs(x+1,y,z+1); if(s[z]==b[y]) dfs(x,y+1,z+1); } int main() { int cas; while(cin&gt;&gt;cas){ for(int cot=1;cot&lt;=cas;cot++){ ans=false; memset(flag,0,sizeof(flag)); cin&gt;&gt;a&gt;&gt;b&gt;&gt;s; dfs(0,0,0); if(ans) cout &lt;&lt;”Data set “&lt;&lt;cot&lt;&lt;”: “&lt;&lt; “yes” &lt;&lt;endl; else cout &lt;&lt;”Data set “&lt;&lt;cot&lt;&lt;”: “&lt;&lt; “no” &lt;&lt; endl; } } return 0; } [/cpp] 下次继续研究广搜与深搜，计划是杭电oj的1072题</cstring></string></iostream></string></iostream></p>

	
	</div>
  <a type="button" href="/2018/04/26/e6-9d-ad-e7-94-b5acm1501-e9-a2-98-ef-bc-9adfs-e7-ae-97-e6-b3-95-e4-b8-8e-e8-ae-b0-e5-bf-86-e5-8c-96-e6-90-9c-e7-b4-a2/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/2018/04/26/e8-ae-b0-e5-bd-95-e7-ac-ac-e4-b8-80-e6-ac-a1-e4-b8-8e-e6-9c-8b-e5-8f-8b-e6-89-93codeforces-div2-e7-ab-9e-e8-b5-9b-ef-bc-88a-e9-a2-98-b-e9-a2-98-cd-e9-a2-98-e6-98-8e-e5-90-8e-e5-a4-a9-e5-b7-a6/" >记录第一次与朋友打Codeforces div2竞赛（A题 B题 CD题明后天左右更新）</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2018-04-26  </div>
		</div>
	</div>
	


			<div class="entry">
  <div class="row">
	
	
		<h4 id="最近练习算法倍感无聊，所以与同学在鼎鼎大名的codeforces上练了练手。不得不说两小时紧张题目还是非常刺激的（特别还是在学校组织的上机时间内完成的），codeforces的题还是非常困难且考验脑力的，最后在争论下，以2次过A题以及幸运的一次过D题而结束。然而在我赛后的研究后，其实B，C二题并不是非常困难，之后我也把B，C两题给A了。今天写这篇文章就是来总结一下这四道题的各种解法以及观摩rating榜上大神的解法。"><a href="#最近练习算法倍感无聊，所以与同学在鼎鼎大名的codeforces上练了练手。不得不说两小时紧张题目还是非常刺激的（特别还是在学校组织的上机时间内完成的），codeforces的题还是非常困难且考验脑力的，最后在争论下，以2次过A题以及幸运的一次过D题而结束。然而在我赛后的研究后，其实B，C二题并不是非常困难，之后我也把B，C两题给A了。今天写这篇文章就是来总结一下这四道题的各种解法以及观摩rating榜上大神的解法。" class="headerlink" title="最近练习算法倍感无聊，所以与同学在鼎鼎大名的codeforces上练了练手。不得不说两小时紧张题目还是非常刺激的（特别还是在学校组织的上机时间内完成的），codeforces的题还是非常困难且考验脑力的，最后在争论下，以2次过A题以及幸运的一次过D题而结束。然而在我赛后的研究后，其实B，C二题并不是非常困难，之后我也把B，C两题给A了。今天写这篇文章就是来总结一下这四道题的各种解法以及观摩rating榜上大神的解法。"></a>最近练习算法倍感无聊，所以与同学在鼎鼎大名的codeforces上练了练手。不得不说两小时紧张题目还是非常刺激的（特别还是在学校组织的上机时间内完成的），codeforces的题还是非常困难且考验脑力的，最后在争论下，以2次过A题以及幸运的一次过D题而结束。然而在我赛后的研究后，其实B，C二题并不是非常困难，之后我也把B，C两题给A了。今天写这篇文章就是来总结一下这四道题的各种解法以及观摩rating榜上大神的解法。</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="http://39.107.233.145/wp-content/uploads/2018/04/1.png" alt=""></h4><h4 id="先来说说A题，其实A题说白了就是找到达数组和一半的数字。看似简单的一题往往会在测试数据上下套，所以这里用到一个上课不讲的技巧"><a href="#先来说说A题，其实A题说白了就是找到达数组和一半的数字。看似简单的一题往往会在测试数据上下套，所以这里用到一个上课不讲的技巧" class="headerlink" title="先来说说A题，其实A题说白了就是找到达数组和一半的数字。看似简单的一题往往会在测试数据上下套，所以这里用到一个上课不讲的技巧"></a>先来说说A题，其实A题说白了就是找到达数组和一半的数字。看似简单的一题往往会在测试数据上下套，所以这里用到一个上课不讲的技巧</h4><p>[cpp] ios_base::sync_with_stdio(0); cin.tie(0); [/cpp]</p>
<h4 id="这两句话用于决定C-标准streams-cin-cout-cerr…-是否与相应的C标准程序库文件-stdin-stdout-stderr-同步，同步意味着带-来更多的负担，cin-tie-0-用于解除cin-cout绑定。通俗来讲，就可以反复读取一大段一大段的输入，在codeforces这种几乎变态的测试-数据下尤为有效。然后就是开一个贼大的long-long数组，一开始的错误就是因为没有处理好超大数据而导致了一次WA。下面附上我A题的AC-代码"><a href="#这两句话用于决定C-标准streams-cin-cout-cerr…-是否与相应的C标准程序库文件-stdin-stdout-stderr-同步，同步意味着带-来更多的负担，cin-tie-0-用于解除cin-cout绑定。通俗来讲，就可以反复读取一大段一大段的输入，在codeforces这种几乎变态的测试-数据下尤为有效。然后就是开一个贼大的long-long数组，一开始的错误就是因为没有处理好超大数据而导致了一次WA。下面附上我A题的AC-代码" class="headerlink" title="这两句话用于决定C++标准streams(cin,cout,cerr…)是否与相应的C标准程序库文件(stdin,stdout,stderr)同步，同步意味着带 来更多的负担，cin.tie(0)用于解除cin cout绑定。通俗来讲，就可以反复读取一大段一大段的输入，在codeforces这种几乎变态的测试 数据下尤为有效。然后就是开一个贼大的long long数组，一开始的错误就是因为没有处理好超大数据而导致了一次WA。下面附上我A题的AC 代码"></a>这两句话用于决定C++标准streams(cin,cout,cerr…)是否与相应的C标准程序库文件(stdin,stdout,stderr)同步，同步意味着带 来更多的负担，cin.tie(0)用于解除cin cout绑定。通俗来讲，就可以反复读取一大段一大段的输入，在codeforces这种几乎变态的测试 数据下尤为有效。然后就是开一个贼大的long long数组，一开始的错误就是因为没有处理好超大数据而导致了一次WA。下面附上我A题的AC 代码</h4><p>[cpp] #include <iostream> #include <cstring> #include <string> using namespace std; long long a[200005]; int main(){ ios_base::sync_with_stdio(0); cin.tie(0); int n; cin&gt;&gt;n; memset(a,0,sizeof(a)); for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; a[i]+=a[i-1]; } for(int i=1;i&lt;=n;i++){ if(a[i]&gt;=(a[n]+1)/2){ cout&lt;&lt;i&lt;&lt;endl; return 0; } } return 0; } [/cpp]</string></cstring></iostream></p>
<h4 id="是不是觉得除了一些细节，A题还是特别简单的，这可是codeforces的开胃菜而已！！-接下来就是刺激的B题了-此题并不算难，可是如果不能做到及时化繁为简，很容易绕到圈子里-首先这是一个排座位的题目，a个A类同学与b个B类同学上火车，火车上有一排座位，座位上放有以‘’表示的墙（我把题的意思简化了，-本来的题意并没有这么无聊），然后限制条件是A和B不能相邻，但是AB类同学旁边都可以放‘’。求最多能放的AB同学的总和。-这个题一上来非常令人害怕，特别是我涛哥（这里艾特下我涛哥）快炸了，其实后来细想并没有刚开始想的这么复杂，主要得抓住问题的-关键–尽可能的多放入A和B，还有一个关键点是号的存在直接导致了思维难度的升高。这里为了理解起来更加的方便，我们先考虑没有-的情况-看吧，是不是特别简单！只要考虑A和B足够的情况下交叉排放即可，所以在没有碰到-的时候，我-们的代码就及其地简单了。通过对前一个变量pre的维护，就可以做到当前一个为A时有B放B，前一个为B时有A放A"><a href="#是不是觉得除了一些细节，A题还是特别简单的，这可是codeforces的开胃菜而已！！-接下来就是刺激的B题了-此题并不算难，可是如果不能做到及时化繁为简，很容易绕到圈子里-首先这是一个排座位的题目，a个A类同学与b个B类同学上火车，火车上有一排座位，座位上放有以‘’表示的墙（我把题的意思简化了，-本来的题意并没有这么无聊），然后限制条件是A和B不能相邻，但是AB类同学旁边都可以放‘’。求最多能放的AB同学的总和。-这个题一上来非常令人害怕，特别是我涛哥（这里艾特下我涛哥）快炸了，其实后来细想并没有刚开始想的这么复杂，主要得抓住问题的-关键–尽可能的多放入A和B，还有一个关键点是号的存在直接导致了思维难度的升高。这里为了理解起来更加的方便，我们先考虑没有-的情况-看吧，是不是特别简单！只要考虑A和B足够的情况下交叉排放即可，所以在没有碰到-的时候，我-们的代码就及其地简单了。通过对前一个变量pre的维护，就可以做到当前一个为A时有B放B，前一个为B时有A放A" class="headerlink" title="是不是觉得除了一些细节，A题还是特别简单的，这可是codeforces的开胃菜而已！！ 接下来就是刺激的B题了(此题并不算难，可是如果不能做到及时化繁为简，很容易绕到圈子里)  首先这是一个排座位的题目，a个A类同学与b个B类同学上火车，火车上有一排座位，座位上放有以‘’表示的墙（我把题的意思简化了， 本来的题意并没有这么无聊），然后限制条件是A和B不能相邻，但是AB类同学旁边都可以放‘’。求最多能放的AB同学的总和。 这个题一上来非常令人害怕，特别是我涛哥（这里艾特下我涛哥）快炸了，其实后来细想并没有刚开始想的这么复杂，主要得抓住问题的 关键–尽可能的多放入A和B，还有一个关键点是号的存在直接导致了思维难度的升高。这里为了理解起来更加的方便，我们先考虑没有 的情况 看吧，是不是特别简单！只要考虑A和B足够的情况下交叉排放即可，所以在没有碰到*的时候，我 们的代码就及其地简单了。通过对前一个变量pre的维护，就可以做到当前一个为A时有B放B，前一个为B时有A放A"></a>是不是觉得除了一些细节，A题还是特别简单的，这可是codeforces的开胃菜而已！！ 接下来就是刺激的B题了(此题并不算难，可是如果不能做到及时化繁为简，很容易绕到圈子里) <img src="http://39.107.233.145/wp-content/uploads/2018/04/b1.png" alt=""> 首先这是一个排座位的题目，a个A类同学与b个B类同学上火车，火车上有一排座位，座位上放有以‘<em>’表示的墙（我把题的意思简化了， 本来的题意并没有这么无聊），然后限制条件是A和B不能相邻，但是AB类同学旁边都可以放‘</em>’。求最多能放的AB同学的总和。 这个题一上来非常令人害怕，特别是我涛哥（这里艾特下我涛哥）快炸了，其实后来细想并没有刚开始想的这么复杂，主要得抓住问题的 关键–尽可能的多放入A和B，还有一个关键点是<em>号的存在直接导致了思维难度的升高。这里为了理解起来更加的方便，我们先考虑没有</em> 的情况 <img src="http://39.107.233.145/wp-content/uploads/2018/04/bs-300x137.png" alt="">看吧，是不是特别简单！只要考虑A和B足够的情况下交叉排放即可，所以在没有碰到*的时候，我 们的代码就及其地简单了。通过对前一个变量pre的维护，就可以做到当前一个为A时有B放B，前一个为B时有A放A</h4><p>[cpp] if(pre==’ ‘){ if(a&gt;b&amp;&amp;a&gt;0){ a–; pre=’a’; sum++; } else{ b–; pre=’b’; sum++; } [/cpp]</p>
<h4 id="所以本题的代码的难度几乎都在如何处理‘’上，那么这就要思考一个问题了，如果我们遇到了，我们究竟该怎么在的左右放AB才能使-AB的数量最大化的。这就要引入这道题的核心–平衡了，从无的情况可以得知，A和B必须交替放置才可以使利益最大化，所以，我在无墙的-空地上必须尽可能地使AB的数量不要相差太多。那么，在遇到时我们就知道该干什么了，这不赶紧把数量多的塞进的左右两边，这样在后续-地放置中才可以更加平衡，也可以放更多的A和B，下面贴出AC代码"><a href="#所以本题的代码的难度几乎都在如何处理‘’上，那么这就要思考一个问题了，如果我们遇到了，我们究竟该怎么在的左右放AB才能使-AB的数量最大化的。这就要引入这道题的核心–平衡了，从无的情况可以得知，A和B必须交替放置才可以使利益最大化，所以，我在无墙的-空地上必须尽可能地使AB的数量不要相差太多。那么，在遇到时我们就知道该干什么了，这不赶紧把数量多的塞进的左右两边，这样在后续-地放置中才可以更加平衡，也可以放更多的A和B，下面贴出AC代码" class="headerlink" title="所以本题的代码的难度几乎都在如何处理‘’上，那么这就要思考一个问题了，如果我们遇到了，我们究竟该怎么在的左右放AB才能使 AB的数量最大化的。这就要引入这道题的核心–平衡了，从无的情况可以得知，A和B必须交替放置才可以使利益最大化，所以，我在无墙的 空地上必须尽可能地使AB的数量不要相差太多。那么，在遇到时我们就知道该干什么了，这不赶紧把数量多的塞进的左右两边，这样在后续 地放置中才可以更加平衡，也可以放更多的A和B，下面贴出AC代码"></a>所以本题的代码的难度几乎都在如何处理‘<em>’上，那么这就要思考一个问题了，如果我们遇到</em>了，我们究竟该怎么在<em>的左右放AB才能使 AB的数量最大化的。这就要引入这道题的核心–平衡了，从无</em>的情况可以得知，A和B必须交替放置才可以使利益最大化，所以，我在无墙的 空地上必须尽可能地使AB的数量不要相差太多。那么，在遇到<em>时我们就知道该干什么了，这不赶紧把数量多的塞进</em>的左右两边，这样在后续 地放置中才可以更加平衡，也可以放更多的A和B，下面贴出AC代码</h4><p>[cpp] #include <iostream> #include <string> #include <cstring> #include <algorithm> using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); long long n,a,b,sum=0; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; char *s=new char[n+10]; for(int i=0;i&lt;n;i++){ cin&gt;&gt;s[i]; } char pre=’ ‘; for(int i=0;i&lt;n;i++){ if(s[i]==’.’){ if(pre==’ ‘){ if(a&gt;b&amp;&amp;a&gt;0){ a–; pre=’a’; sum++; } else{ b–; pre=’b’; sum++; } } else if(pre==’a’&amp;&amp;b&gt;0){ b–; pre=’b’; sum++; } else if(pre==’b’&amp;&amp;a&gt;0){ a–; pre=’a’; sum++; } else pre=’ ‘; } else{ pre=’ ‘; } if(a==0&amp;&amp;b==0) break; } cout &lt;&lt; sum &lt;&lt; endl; return 0; } [/cpp]</algorithm></cstring></string></iostream></p>
<h4 id="今天就先更新到B题，更加刺激精彩的C、D两题以后再写，各位晚安。"><a href="#今天就先更新到B题，更加刺激精彩的C、D两题以后再写，各位晚安。" class="headerlink" title="今天就先更新到B题，更加刺激精彩的C、D两题以后再写，各位晚安。"></a>今天就先更新到B题，更加刺激精彩的C、D两题以后再写，各位晚安。</h4>
	
	</div>
  <a type="button" href="/2018/04/26/e8-ae-b0-e5-bd-95-e7-ac-ac-e4-b8-80-e6-ac-a1-e4-b8-8e-e6-9c-8b-e5-8f-8b-e6-89-93codeforces-div2-e7-ab-9e-e8-b5-9b-ef-bc-88a-e9-a2-98-b-e9-a2-98-cd-e9-a2-98-e6-98-8e-e5-90-8e-e5-a4-a9-e5-b7-a6/#more" class="btn btn-default more">阅读此文</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="搜索" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>分类</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/ACM/">ACM<span>8</span></a></li>
		
			<li><a href="/categories/Codeforces/">Codeforces<span>1</span></a></li>
		
			<li><a href="/categories/ACM/LeetCode/">LeetCode<span>1</span></a></li>
		
			<li><a href="/categories/ACM/UVA/">UVA<span>1</span></a></li>
		
			<li><a href="/categories/ACM/北大oj/">北大oj<span>1</span></a></li>
		
			<li><a href="/categories/未分类/">未分类<span>0</span></a></li>
		
			<li><a href="/categories/ACM/杭电oj/">杭电oj<span>2</span></a></li>
		
		</ul>
	</div>

		
			

		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2018/07/18/个人博客2-0上线了/" ><i class="fa fa-file-o"></i>个人博客2.0上线了</a>
      </li>
    
      <li>
        <a href="/2018/07/18/e9-93-be-e5-bc-8f-e5-93-88-e5-b8-8c-e8-a1-a8-ef-bc-88-e5-85-ab-e6-95-b0-e7-a0-81-e9-97-ae-e9-a2-98-e6-89-a9-e5-b1-95-ef-bc-89/" ><i class="fa fa-file-o"></i>链式哈希表（八数码问题扩展）</a>
      </li>
    
      <li>
        <a href="/2018/07/17/e5-85-ab-e6-95-b0-e7-a0-81-e9-97-ae-e9-a2-98bfs-e5-ba-b7-e6-89-98-e5-b1-95-e5-bc-80/" ><i class="fa fa-file-o"></i>八数码问题(BFS+康托展开)</a>
      </li>
    
      <li>
        <a href="/2018/07/16/e5-ba-b7-e6-89-98-e5-b1-95-e5-bc-80-ef-bc-88-e5-85-a8-e6-8e-92-e5-88-97-e4-b8-8e-e8-87-aa-e7-84-b6-e6-95-b0-e7-9a-84-e5-8f-8c-e5-b0-84-ef-bc-89/" ><i class="fa fa-file-o"></i>康托展开（全排列与自然数的双射）</a>
      </li>
    
      <li>
        <a href="/2018/07/15/leetcode-e5-91-a8-e8-b5-9b-e7-ac-ac93-e5-9c-ba-e8-a7-a3-e9-a2-98-e6-8a-a5-e5-91-8a/" ><i class="fa fa-file-o"></i>Leetcode周赛第93场解题报告</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/wzpan/hexo-theme-freemind" title="Freemind's Github repository." target="_blank"]);">Freemind</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/kristopolous/BOOTSTRA.386" title="BOOTSTRA.386's Github repository." target="_blank"]);">BOOTSTRA.386</a></li>
	
		<li><i class="fa fa-github"></i><a href="https://github.com/blackshow/hexo-theme-freemind.386" title="Freemind.386's Github repository." target="_blank"]);">Freemind.386</a></li>
	
		<li><i class="fa fa-github"></i><a href="http://www.github.com/blackshow" title="My Github account." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2018 Eric
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
